# CI/CD

## What is CI/CD?
- CI: Continuous Integration
    - Automatically run tests/checks on every new code push or PR.
    - It helps to prevent integration problems, allowing teams to develop cohesive software more rapidly.
- CD: Continuous Delivery/Deployment
    - Automatically deploy your app when code passes all checks
    - Code is always in a deployable state.

CI/CD is a set of practices that enable development teams to deliver code changes more frequently and reliably. It reduce the manual work and automatically test and deploy code changes, ensuring that software is always in a releasable state.

## Set up CI/CD pipeline
- I use GitHub Actions to set up CI/CD pipeline.
- I install mardkdownlint and cspell locally to lint my markdown files and check spelling.
    ```bash
        # Install markdownlint and cspell
        npm install --save-dev markdownlint-cli cspell
    ```
    - I ran the spell-check and the screenshot below is the result. As you can see, there are some spelling errors in the markdown files.
        ![spell-check result](<Screenshot 2025-06-17 at 3.12.02 pm.png>)
    - I also used the `codespell -w` command to automatically fix some of the spelling errors, but I still need to manually fix some of them.
      - I noticed that some of the spelling errors were fixed, but the codespell command accidentally edited some of the words in node_modules, which I had to revert by using `git checkout -- .` command that I learned in the previous milestone.
    - And I ran the markdownlint and the result is shown below. I further analysed the terminal messages and understood the rules code:
        ```md
            MD026 | Remove trailing : in headings
            MD041 | Change first heading to level 1 (#)
            MD025 | Only one # heading per file
            MD001 | Ensure heading levels increment correctly (no skipping levels)
            MD033 | Replace inline HTML <img> with markdown ![alt text](url)
            MD045 | Add alt text for all images
            MD038 | Remove spaces inside inline code spans
            MD010 | Replace hard tabs with spaces
            MD007 | Fix list indentation to 2 spaces    
            MD009 | Fix trailing spaces
        ```
        ![Terminal message for checking markdownlint](image.png)
- Then I created CI workflow using GitHub Actions. 
  - The workflow is defined in `.github/workflows/ci.yml` file (the yaml file is generated by ChatGPT).
    ```yaml
      name: CI Markdown Lint & Spell Check

        on:
          pull_request:
            branches: [main]

        jobs:
          lint:
            runs-on: ubuntu-latest

            steps:
            - name: Checkout repo
              uses: actions/checkout@v3

            - name: Setup Node.js
              uses: actions/setup-node@v3
              with:
                node-version: '18'

            - name: Install dependencies
              run: npm install

            - name: Run Markdown Lint
              run: npm run lint-md

            - name: Run Spell Check
              run: npm run spell-check
    ```
  - I believe this workflow can run checks on every pull request to the main branch, ensuring that all markdown files are linted and spell-checked before merging.

## Husky
- I also set up Husky to run the linting and spell-checking commands before committing code changes (~/.husky).
  - Husky is a tool that allows you to create Git hooks, which are scripts that run at certain points in the Git workflow.
  - The screenshot shows how I set up Husky to run the linting and spell-checking commands before committing code changes.
    ![Husky setup CLI 1](<Screenshot 2025-06-17 at 3.34.02 pm.png>)
    ![Husky setup CLI 2](<Screenshot 2025-06-17 at 3.36.18 pm.png>)
  - Now, when I try to commit code changes, Husky will run the linting and spell-checking commands first. If there are any errors, the commit will be aborted, and I will need to fix the errors before committing again.
    ![Husky commit error](<Screenshot 2025-06-17 at 3.37.44 pm.png>)
  - I noticed that I have many formatting and spelling errors in my markdown files, but I think I can fix them later. Therefore, I will make Husky run with warnings, not blocking my commits at the moment.
    - I modified the Husky script to run with warnings:
      ```bash
      #!/bin/sh
      . "$(dirname "$0")/_/husky.sh"

      npm run lint-md || echo "Markdown linting failed, but continuing with commit."
      npm run spell-check || echo "Spell check failed, but continuing with commit."
      ```

## Reflection Questions
### What is the purpose of CI/CD?

The purpose of CI/CD (Continuous Integration and Continuous Deployment) is to automate the process of integrating code changes, running tests, and deploying applications. 
- CI (Continuous Integration) ensures that new code changes are automatically built and tested, helping to catch bugs early and keep the codebase stable. 
- CD (Continuous Deployment or Delivery) automates the release process, making it faster and more reliable to deliver updates to users. Together, CI/CD reduces manual work, speeds up development, and improves software quality.

### How does automating style checks improve project quality?

Automating style checks ensures consistent code formatting, documentation standards, and coding practices across the entire project. This improves code readability and makes collaboration easier across different team members. Automated checks also catch formatting issues early, preventing small issues from accumulating over time.

### What are some challenges with enforcing checks in CI/CD?

Strict automated checks can sometimes block code from being merged if minor issues are not fixed, which may slow down development under tight deadlines. It may also require extra time to configure and maintain the rules. For example, my experience for this issue #71 with Husky and lint-staged showed that while these tools are powerful, they can also be a source of frustration if not configured properly. Occasionally, some checks may produce false positives, which require manual review and adjustment of rules.

### How do CI/CD pipelines differ between small projects and large teams?

- In small projects, CI/CD pipelines are usually simpler, focusing on basic tests, linting, and deployments, and can be adjusted quickly. 
- In large teams, pipelines are more complex and include multiple stages such as code review gates, automated testing (unit, integration, end-to-end), security scans, and multi-environment deployments. They require careful coordination to ensure stability, scalability, and consistent code quality.

    
