# Clean Code Principles, Formatting, and Testing
## Clean Code Principles:
üß† What Is Clean Code?

Clean code is code that is easy to read, understand and change. Writing clean code isn‚Äôt just about aesthetics ‚Äî it‚Äôs about writing code that works well for both machines and humans.

It follows principles like:
- **Simplicity**: Keep it simple and straightforward. Avoid unnecessary complexity like nested loops or convoluted logic.
- **Readability**: Since code is read more often that it is written, use descriptive names for variables and functions, and keep lines short. Add comments only when necessary to explain *why*, not *what*.
- **Maintainability**: Write code that is easy to update and adapt. This means avoiding hard-coded values, using constants, and keeping functions focused on a single task with consistent naming conventions.
- **Consistency**: Use consistent naming conventions and formatting throughout the codebase. This helps other developers and myself understand the code quickly.
- **Efficiency**: Performance is important, but it should not come at the cost of readability. Write code that is efficient but also clear and understandable but also aim for fast execution times and low memory usage.

Here is an example of Messy Code (generated by ChatGPT):
```ts
function calc(a, b, c) {
  if (c === "+") {
    return a + b;
  } else if (c === "-") {
    return a - b;
  } else if (c === "*") {
    return a * b;
  } else if (c === "/") {
    return a / b;
  } else {
    return "err";
  }
}
```

And here is the refactored Clean Code version:
```ts
/**
 * Performs a basic arithmetic operation on two numbers.
 * @param num1 - The first number.
 * @param num2 - The second number.
 * @param operator - One of '+', '-', '*', '/'.
 * @returns The result of the operation or throws an error for invalid input.
 */
function calculate(num1: number, num2: number, operator: string): number {
  switch (operator) {
    case "+":
      return num1 + num2;
    case "-":
      return num1 - num2;
    case "*":
      return num1 * num2;
    case "/":
      if (num2 === 0) throw new Error("Cannot divide by zero");
      return num1 / num2;
    default:
      throw new Error("Invalid operator");
  }
```
In the refactored version, the code is clearer and easier to understand:
- The function name `calculate` describes its purpose.
- The parameters are typed, aka `Type-safe`, making it clear what types of values are expected.
- The switch statement is more readable than multiple if-else statements.
- Error handling is added for invalid operators and division by zero, making the function more robust.
- JSDoc comments explain the function's purpose, parameters, and return value, improving documentation.

## Code Formatting & Style Guides
Code formatting improves readability, reduces misunderstandings, and helps teams collaborate more effectively. Consistent style also makes it easier to spot bugs and understand unfamiliar code.

I reviewed the [Airbnb JavaScript Style Guide](https://github.com/airbnb/javascript) and the [Google TypeScript Style Guide](https://google.github.io/styleguide/tsguide.html) to understand common formatting practices. Here are some key takeaways:

### üìè Airbnb JavaScript Style Guide
- Modern ES6+ preferences: Use const/let, arrow functions, template literals, destructuring, default parameters‚Äîthis keeps code concise and safe
- Destructuring: Prefer extracting properties from objects/arrays ‚áí cleaner and less repetitive code
- Consistent spacing and formatting: Spaces around operators (e.g. x = y + 5), no semicolons misuse, indent chained calls ‚Äì keeps code readable
- No arguments, no param reassign: Use rest (...args) and never change function params ‚Äì avoids ambiguity and hidden bugs

### üìù Google TypeScript Style Guide
- Naming conventions:
    - PascalCase for classes/types/interfaces.
    - lowerCamelCase for variables/functions.
	- CONSTANT_CASE for global constants.
- File structure:
	- Order: optional copyright ‚Üí @fileoverview ‚Üí imports ‚Üí code, each separated by blank lines.
- Prefer named imports/exports: Avoid default exports ‚Äì clearer and safer for tooling.
- ESLint/Prettier enforcement: These guidelines are meant to be enforced automatically for consistency.

I followed the instructions in issue #62, I installed ESLint and Prettier in this development environment. 

## Clean Code Testing
### How do unit tests help keep code clean?

Writing unit tests for `formatUser` function `from test/userUtils.ts` helped clarify the function‚Äôs intended behaviour and made the code easier to reason about. Based on my own experience writing and running these tests, here‚Äôs how they improved the code:

---

‚úÖ **1. Clarified function behaviour**  
By explicitly testing:
- `formatUser(testUser)` ‚ûù `Jane Doe <jane.doe@example.com>`  
- `formatUser(testUser, true)` ‚ûù `Jane Doe <ja***@example.com>`  

‚Ä¶it became clear what the function is expected to do. This removes ambiguity for future developers (or my future self) and avoids needing to read the implementation to understand its purpose.

---

‚úÖ **2. Encouraged simpler, modular code**  
To pass the tests, the function had to:
- stay focused on a single task (formatting + optional masking),
- avoid unrelated logic or side effects,
- stay short and easy to read.  

This aligns well with clean code principles like **single responsibility** and **readability**.

---

‚úÖ **3. Made the function safer and more predictable**  
Even though I didn‚Äôt write all edge case tests yet, writing the initial tests made me think about inputs like:
- short or malformed emails,
- missing names or null values.

This mindset reduces bugs and improves long-term maintainability.

---

‚úÖ **4. Gave confidence to refactor**  
With tests in place, I now have a safety net. If I or someone else changes the function later, the tests will catch regressions. This gives me confidence to refactor while keeping the code clean and functional.

---

If I had more time, I‚Äôd also consider adding tests for edge cases like:
- empty `firstName` or `lastName`
- malformed or missing email
- `undefined` or `null` user input

These would help push the function toward being even cleaner and more defensive.

### What issues did you find while testing?

- The function didn‚Äôt handle edge cases like missing names, short or malformed emails, or `undefined` input.
- It assumed valid input without checks, which could cause errors in real-world use (e.g., API data).
- Writing tests revealed the need for validation and defensive coding.
- The process showed how even basic testing improves reliability and highlights weak spots.

When implementing the Jest tests, I got an error saying describe was not defined ‚Äî I realised I needed to configure Jest properly in my TypeScript project. Once resolved, I noticed that testing forced me to better structure the code. It made me more aware of naming clarity and handling optional parameters like maskEmail. Overall, the process helped me think more critically about clean design and function responsibility.

I ran the tests using the command:
```bash
npx jest
```
and they passed successfully, as shown in the screenshot below:
![Test for running jest](<Screenshot 2025-06-19 at 3.08.50‚ÄØpm.png>)


## Error Handling & Gaurd Clauses

- **Error handling**: preventing your app from crashing or behaving unpredictably when things go wrong.
- **Guard clauses** early return conditions to handle invalid input or stop execution early.

So from the previous issue, I created userUtils.ts with a `formatUser` function that formats user data. Now, I‚Äôll add error handling and guard clauses to make it more robust.


### What was the issue with the original code?

In the earlier version of my `formatUser` function, there were no checks for invalid or incomplete input. If the function received `undefined`, `null`, or an object without a `firstName` or `lastName`, it would still attempt to run and return unpredictable or broken output ‚Äî or even throw an error. This made the function fragile and harder to maintain.

---

### How does handling errors improve reliability?

I added basic **error handling** using **guard clauses** ‚Äî early return conditions that stop the function from continuing if the input isn‚Äôt valid. For example:

```ts
if (!user || typeof user !== 'object') return 'Invalid user';
if (!user.firstName || !user.lastName) return 'Missing name';
```
So that it checks for invalid input like not having a user object or missing names. This prevents errors later on.  This not only made the function safer but also improved readability by reducing unnecessary nesting.


## Commenting & Documentation

I asked myself, "How can I make my code easier to understand for others (and myself in the future)?"
What are some of the best practices for writing comments and documentation? Besides the practices that I have already done in previous issues and experiences, I found these tips helpful:

### ‚úÖ What I‚Äôve Already Done During This Internship

- **Descriptive file-level comments**  
  ‚Üí I added a short summary at the top of `userUtils.ts` explaining the purpose of the file.
  ```ts
  /** 
   * userUtils.ts
   * This module provides utility functions for formatting user information. 
   * It includes an options parameter for email masking.
   **/
    ```
- **Clear function documentation using JSDoc**
    ‚Üí I documented formatUser with parameter descriptions, return value, and usage behaviour:
    ```ts
    /**
    * Formats a user's full name and email.
    * If maskEmail is true, the email will be partially masked for privacy.
    * Falls back to an empty string if email is missing or undefined.
    *
    * @param user - The user object containing firstName, lastName, and optional email.
    * @param maskEmail - Whether to mask the email address.
    * @returns A formatted string like "John Doe <jo***@domain.com>"
    */
    ```
    This kind of documentation improves clarity and helps other developers understand how to use the function correctly without digging into the implementation.

### ‚ùå What I Could Improve
**When to Use Comments**
- To explain why something is done (not just what is done).
- When working with complex logic that may not be self-explanatory.

And I think it is also important to **improve the code itself (clean codes)** instead of writing a comment to explain it. If the code is clear and self-explanatory, comments may not be necessary. For example:
- Clear naming (like formatUser) reduces the need for comments.
- Short, focused functions often explain themselves.
- Comments should not repeat what the code already clearly says.


### üí¨ When should you add comments?

I found comments most helpful when they explain **why** something is done, especially if the reason isn‚Äôt obvious just by looking at the code. I used file-level comments to give context at the top of the `userUtils.ts` file and JSDoc comments to describe what the `formatUser` function does and how to use it.

So for me, I add comments when:
- I want to give a quick summary of what the file or function is about.
- The logic might not be super obvious at first glance.
- I‚Äôm writing utility code that someone else might use or maintain later.


### ü§´ When should you avoid comments and instead improve the code?

As I mentioned, I realised that sometimes the best way to make code clear is to **write it more clearly** ‚Äî not explain it after the fact. For example, instead of writing a comment like `// this function formats the user`, I made sure the function is just called `formatUser`.

I try to avoid comments when:
- The code can be made clearer with better names.
- The comment is just repeating what the code says.
- A small refactor (like splitting logic into smaller functions) would make things self-explanatory.

This way, the code stays cleaner and easier to maintain without relying too much on comments that might get outdated later.

### Additional content: Naming Conventions Across Languages

Understanding language-specific naming styles helps us write more idiomatic and readable code ‚Äî and shows that we know what we're doing. Useful reference: https://www.freecodecamp.org/news/programming-naming-conventions-explained/. The table below summarises common naming conventions accross differnt programming languages, including the ones I‚Äôve been using at Focus Bear (generated by ChatGPT).

---

### ‚úÖ JavaScript / TypeScript (what I‚Äôve been using)

| Element         | Convention   | Example             |
|-----------------|--------------|---------------------|
| Variable        | `camelCase`  | `userEmail`, `isValid` |
| Function        | `camelCase`  | `formatUser()`      |
| Class / Interface | `PascalCase` | `User`, `EmailSender` |
| Constants       | `SCREAMING_SNAKE_CASE` | `MAX_RETRIES` |

---

### üêç Python

| Element         | Convention       | Example               |
|-----------------|------------------|-----------------------|
| Variable        | `snake_case`     | `user_email`          |
| Function        | `snake_case`     | `format_user()`       |
| Class           | `PascalCase`     | `EmailFormatter`      |
| Constant        | `SCREAMING_SNAKE_CASE` | `MAX_RETRIES`   |

---

### ‚òï Java

| Element         | Convention       | Example               |
|-----------------|------------------|-----------------------|
| Variable        | `camelCase`      | `userEmail`           |
| Method          | `camelCase`      | `getFormattedEmail()` |
| Class / Interface | `PascalCase`   | `UserManager`         |
| Constant        | `SCREAMING_SNAKE_CASE` | `MAX_USERS`   |
> üü° Similar to TypeScript, but *stricter* about things like file name = class name.

---

### üõ† Assembly (depends on assembler, but generally)

| Element         | Convention       | Example               |
|-----------------|------------------|-----------------------|
| Labels / Variables | `UPPER_CASE` or `snake_case` | `LOOP_START`, `data_buffer` |
| Macros          | `UPPER_CASE`     | `DEFINE_SIZE`         |
| Comments        | Start with `;`   | `; This is a comment` |
> üîß Assembly is low-level and not standardised; readability is up to the programmer.

---

### üóÉ SQL

| Element         | Convention       | Example               |
|-----------------|------------------|-----------------------|
| Table names     | `snake_case` or `PascalCase` | `user_data`, `UserData` |
| Column names    | `snake_case`     | `first_name`, `email_address` |
| Aliases         | Usually lowercase | `SELECT * FROM users u` |
> üü† SQL doesn't enforce naming conventions, but readability is key in large queries.

---

### üìò Summary: When in doubt
Use names that are:
- **Descriptive** (avoid `x`, `data1`, `temp` unless temporary)
- **Consistent** with the language and team style
- **Self-explanatory** enough that comments aren‚Äôt always needed





