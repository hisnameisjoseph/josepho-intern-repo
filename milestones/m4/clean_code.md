# Clean Code Principles, Formatting, and Testing
## Clean Code Principles:
üß† What Is Clean Code?

Clean code is code that is easy to read, understand and change. Writing clean code isn‚Äôt just about aesthetics ‚Äî it‚Äôs about writing code that works well for both machines and humans.

It follows principles like:
- **Simplicity**: Keep it simple and straightforward. Avoid unnecessary complexity like nested loops or convoluted logic.
- **Readability**: Since code is read more often that it is written, use descriptive names for variables and functions, and keep lines short. Add comments only when necessary to explain *why*, not *what*.
- **Maintainability**: Write code that is easy to update and adapt. This means avoiding hard-coded values, using constants, and keeping functions focused on a single task with consistent naming conventions.
- **Consistency**: Use consistent naming conventions and formatting throughout the codebase. This helps other developers and myself understand the code quickly.
- **Efficiency**: Performance is important, but it should not come at the cost of readability. Write code that is efficient but also clear and understandable but also aim for fast execution times and low memory usage.

Here is an example of Messy Code (generated by ChatGPT):
```ts
function calc(a, b, c) {
  if (c === "+") {
    return a + b;
  } else if (c === "-") {
    return a - b;
  } else if (c === "*") {
    return a * b;
  } else if (c === "/") {
    return a / b;
  } else {
    return "err";
  }
}
```

And here is the refactored Clean Code version:
```ts
/**
 * Performs a basic arithmetic operation on two numbers.
 * @param num1 - The first number.
 * @param num2 - The second number.
 * @param operator - One of '+', '-', '*', '/'.
 * @returns The result of the operation or throws an error for invalid input.
 */
function calculate(num1: number, num2: number, operator: string): number {
  switch (operator) {
    case "+":
      return num1 + num2;
    case "-":
      return num1 - num2;
    case "*":
      return num1 * num2;
    case "/":
      if (num2 === 0) throw new Error("Cannot divide by zero");
      return num1 / num2;
    default:
      throw new Error("Invalid operator");
  }
```
In the refactored version, the code is clearer and easier to understand:
- The function name `calculate` describes its purpose.
- The parameters are typed, aka `Type-safe`, making it clear what types of values are expected.
- The switch statement is more readable than multiple if-else statements.
- Error handling is added for invalid operators and division by zero, making the function more robust.
- JSDoc comments explain the function's purpose, parameters, and return value, improving documentation.

## Code Formatting & Style Guides
Code formatting improves readability, reduces misunderstandings, and helps teams collaborate more effectively. Consistent style also makes it easier to spot bugs and understand unfamiliar code.

I reviewed the [Airbnb JavaScript Style Guide](https://github.com/airbnb/javascript) and the [Google TypeScript Style Guide](https://google.github.io/styleguide/tsguide.html) to understand common formatting practices. Here are some key takeaways:

### üìè Airbnb JavaScript Style Guide
- Modern ES6+ preferences: Use const/let, arrow functions, template literals, destructuring, default parameters‚Äîthis keeps code concise and safe
- Destructuring: Prefer extracting properties from objects/arrays ‚áí cleaner and less repetitive code
- Consistent spacing and formatting: Spaces around operators (e.g. x = y + 5), no semicolons misuse, indent chained calls ‚Äì keeps code readable
- No arguments, no param reassign: Use rest (...args) and never change function params ‚Äì avoids ambiguity and hidden bugs

### üìù Google TypeScript Style Guide
- Naming conventions:
    - PascalCase for classes/types/interfaces.
    - lowerCamelCase for variables/functions.
	- CONSTANT_CASE for global constants.
- File structure:
	- Order: optional copyright ‚Üí @fileoverview ‚Üí imports ‚Üí code, each separated by blank lines.
- Prefer named imports/exports: Avoid default exports ‚Äì clearer and safer for tooling.
- ESLint/Prettier enforcement: These guidelines are meant to be enforced automatically for consistency.

I followed the instructions in issue #62, I installed ESLint and Prettier in this development environment.
![Message in Terminal for installing Eslint](<Screenshot 2025-06-19 at 6.58.40‚ÄØpm.png>)

### *Troubleshooting ESLint Configuration Issues*
While attempting to fix ESLint warnings across the codebase, I edited the package.json file to manage dependencies. Unfortunately, this introduced several issues where ESLint could no longer run due to missing or invalid packages (e.g. wrap-ansi-cjs, string-width-cjs, etc.), throwing ETARGET errors during npm install. This broke the entire linting setup and made it impossible to proceed.

I was stuck in this state for a while. Eventually, I resolved it by manually copying the Markdown files I had already fixed (based on ESLint‚Äôs output) to a safe location, then reverting the whole repository to the last working git commit. This allowed me to restore a clean dependency setup, reinstall the correct packages, and paste my edited .md files back in. After doing this, I was finally able to run npx eslint again without errors.

This experience taught me the importance of being cautious when modifying package.json, especially when working within a shared or version-controlled project. In future, I‚Äôll make sure to create a backup or branch before making such changes.

### Why is code formatting important?
Consistent code formatting improves readability and makes collaboration smoother. During this task, I realised how a well-formatted codebase helps quickly identify issues, especially when working across Markdown, TypeScript, and JSON files.

### What issues did the linter detect?
The linter flagged missing alt text for images, multiple H1 headings, heading level skips in Markdown files, use of any types in TypeScript, and malformed JSON. It also detected style issues like indentation and missing code block languages.

*Originally, I had multiple problems with the Markdown files (around 20 problems), and now I have fixed most of them, leaving only 8 problems related to the node packages and a messy ts file (supposed to be messy, as an example) remaining. As shown below:*
```bash
(base) hisnameisjoseph@Josephs-MacBook-Pro-14 josepho-intern-repo % npx eslint . --ext .ts,.js

/Users/hisnameisjoseph/Documents/485/Project 485/FocusBear/josepho-intern-repo/milestones/m3/practice/package-lock.json
  7:5  error  Empty key found  json/no-empty-keys

/Users/hisnameisjoseph/Documents/485/Project 485/FocusBear/josepho-intern-repo/milestones/m3/practice/tsconfig.json
  3:5  error  Parsing error: Unexpected character '/' found

/Users/hisnameisjoseph/Documents/485/Project 485/FocusBear/josepho-intern-repo/milestones/m4/UserManager.ts
   5:11  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
   6:9   error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  13:24  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  34:27  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any
  41:13  error  Unexpected any. Specify a different type  @typescript-eslint/no-explicit-any

/Users/hisnameisjoseph/Documents/485/Project 485/FocusBear/josepho-intern-repo/package-lock.json
  6:5  error  Empty key found  json/no-empty-keys

‚úñ 8 problems (8 errors, 0 warnings)
```

### Did formatting the code make it easier to read?
Yes, after applying lint fixes, the structure and clarity of the Markdown files improved significantly. It also helped me better understand and clean up problematic areas, especially heading hierarchies and code block consistency.

## Naming Variables & Functions
### Research best practices for naming variables and functions.
Understanding language-specific naming styles helps us write more idiomatic and readable code ‚Äî and shows that we know what we're doing. Useful reference: https://www.freecodecamp.org/news/programming-naming-conventions-explained/. The table below summarises common naming conventions accross different programming languages, including the ones I‚Äôve been using at Focus Bear (generated by ChatGPT).

#### ‚úÖ JavaScript / TypeScript (what I‚Äôve been using)

| Element         | Convention   | Example             |
|-----------------|--------------|---------------------|
| Variable        | `camelCase`  | `userEmail`, `isValid` |
| Function        | `camelCase`  | `formatUser()`      |
| Class / Interface | `PascalCase` | `User`, `EmailSender` |
| Constants       | `SCREAMING_SNAKE_CASE` | `MAX_RETRIES` |

---

#### üêç Python

| Element         | Convention       | Example               |
|-----------------|------------------|-----------------------|
| Variable        | `snake_case`     | `user_email`          |
| Function        | `snake_case`     | `format_user()`       |
| Class           | `PascalCase`     | `EmailFormatter`      |
| Constant        | `SCREAMING_SNAKE_CASE` | `MAX_RETRIES`   |

---

#### ‚òï Java

| Element         | Convention       | Example               |
|-----------------|------------------|-----------------------|
| Variable        | `camelCase`      | `userEmail`           |
| Method          | `camelCase`      | `getFormattedEmail()` |
| Class / Interface | `PascalCase`   | `UserManager`         |
| Constant        | `SCREAMING_SNAKE_CASE` | `MAX_USERS`   |
> üü° Similar to TypeScript, but *stricter* about things like file name = class name.

---

#### üõ† Assembly (depends on assembler, but generally)

| Element         | Convention       | Example               |
|-----------------|------------------|-----------------------|
| Labels / Variables | `UPPER_CASE` or `snake_case` | `LOOP_START`, `data_buffer` |
| Macros          | `UPPER_CASE`     | `DEFINE_SIZE`         |
| Comments        | Start with `;`   | `; This is a comment` |
> üîß Assembly is low-level and not standardised; readability is up to the programmer.

---

#### üóÉ SQL

| Element         | Convention       | Example               |
|-----------------|------------------|-----------------------|
| Table names     | `snake_case` or `PascalCase` | `user_data`, `UserData` |
| Column names    | `snake_case`     | `first_name`, `email_address` |
| Aliases         | Usually lowercase | `SELECT * FROM users u` |
> üü† SQL doesn't enforce naming conventions, but readability is key in large queries.

---

#### üìò Summary: When in doubt
Use names that are:
- **Descriptive** (avoid `x`, `data1`, `temp` unless temporary)
- **Consistent** with the language and team style
- **Self-explanatory** enough that comments aren‚Äôt always needed

### Find examples of unclear variable names in an existing codebase (or write your own).
Since I don't really have unclear variable names in my codebase (I have been following the naming conventions), I will create a simple example of unclear variable names and then refactor it to improve clarity.
#### Example of unclear variable names:
```ts
function d(a: number, b: number): number {
  const c = a + b;
  return c;
}

const x = d(5, 10);
console.log(x);
```

### Refactor the code by renaming variables/functions for better clarity.
#### Refactored Code from the example above:
```ts
function addTwoNumbers(firstNumber: number, secondNumber: number): number {
  const sum = firstNumber + secondNumber;
  return sum;
}

const result = addTwoNumbers(5, 10);
console.log(result);
```

### Reflection Questions:
#### What makes a good variable or function name?
A good variable or function name should be:
- **Clear**
- **Descriptive**
- **Consistent**

It should communicate the intent or purpose of the variable or function without needing extra comments. For example, addTwoNumbers is much easier to understand than d, which could mean anything. Good names also follow the conventions of the language being used, like camelCase for JavaScript/TypeScript.

#### What issues can arise from poorly named variables?
Poorly named variables (e.g., temp, data1, a) make code harder to read, debug, and maintain. They can lead to misunderstandings or mistakes when working in teams, especially if someone else also works on the code. I‚Äôve realised even simple code can become confusing if the naming is vague.

#### How did refactoring improve code readability?
In my simple example, I refactored a vague function (d) and its parameters (a, b, c) into clearer names like addTwoNumbers, firstNumber, and sum. This small change made the purpose of the code obvious at a glance. It also reminded me how naming is a key part of clean code ‚Äî good names act like documentation and help other developers (and my future self) quickly understand the logic.


## Writing Small, Focused Functions

### Research best practices for writing small, single-purpose functions.
From my expereince and research on clean code, I found that writing small, focused functions is a key principle for maintainable code. Here are some best practices:
- **Single Responsibility Principle**: Each function should **do one thing** and **do it well**. This makes it easier to understand, test, and reuse.
- **Descriptive Names**: Use clear, descriptive names that indicate what the function does. Avoid generic names like `doSomething` or `processData`.
- **Short Functions**: Aim for functions that fit within a single screen. If a function is too long, consider breaking it up into smaller helper functions.
- **Avoid Side Effects**: Functions should not modify global state or have hidden dependencies. They should only operate on their input parameters and return a result.
- **Consistent Return Types**: Functions should return the same type of value consistently. This makes it easier to reason about their behaviour.
- **Use Parameters Wisely**: Limit the number of parameters to 2-3. If you need more, consider using an object to group related parameters together.
- **Avoid Deep Nesting**: If a function has too many nested blocks (like if statements), it can become hard to follow. Use early returns or break complex logic into smaller functions to keep the structure flat and readable.

### Find an example of a long, complex function in an existing codebase (or write your own).
```ts
function sortUsers(users: { name: string; age: number }[]) {
  for (let i = 0; i < users.length - 1; i++) {
    for (let j = i + 1; j < users.length; j++) {
      if (users[i].name.toLowerCase() > users[j].name.toLowerCase()) {
        const temp = users[i];
        users[i] = users[j];
        users[j] = temp;
      }
    }
  }

  for (let i = 0; i < users.length; i++) {
    users[i].name = users[i].name.trim();
    users[i].name = users[i].name.charAt(0).toUpperCase() + users[i].name.slice(1);
  }

  console.log("Sorted and formatted user list:");
  console.log(users);
}
```
As you can see, this function does multiple things:
1. Sorts the users by name.
2. Trims whitespace from names.
3. Capitalises the first letter of each name.
4. Logs the sorted list to the console.
With nested for loops and multiple responsibilities, it‚Äôs complex and hard to read.

### Refactor it into multiple smaller functions with clear responsibilities.
```ts
// Define a type for user objects to ensure consistent structure
type User = { name: string; age: number };

/**
 * Cleans up and capitalises a user's name.
 * Trims whitespace and ensures the first letter is uppercase,
 * while the rest is lowercase (e.g. "  alice " ‚Üí "Alice").
 */
function normalizeName(name: string): string {
  const trimmed = name.trim();
  return trimmed.charAt(0).toUpperCase() + trimmed.slice(1).toLowerCase();
}

/**
 * Returns a new array of users sorted alphabetically by name.
 * Uses a case-insensitive comparison for consistent sorting.
 */
function sortUsersByName(users: User[]): User[] {
  return users.slice().sort((a, b) =>
    a.name.toLowerCase().localeCompare(b.name.toLowerCase())
  );
}

/**
 * Returns a new array of users with their names normalised.
 * Uses `normalizeName` to improve data consistency and display quality.
 */
function formatUsers(users: User[]): User[] {
  return users.map(user => ({
    ...user,
    name: normalizeName(user.name),
  }));
}

/**
 * Logs the final list of users to the console.
 * Separated into its own function for clarity and reuse.
 */
function displayUsers(users: User[]): void {
  console.log("Sorted and formatted user list:");
  console.log(users);
}

/**
 * Main function that processes a list of users.
 * Applies sorting, formatting, and then displays the result.
 * Keeps each step modular and easy to test or extend.
 */
function processUsers(users: User[]): void {
  const sorted = sortUsersByName(users);
  const formatted = formatUsers(sorted);
  displayUsers(formatted);
}
```
This refactored code breaks down the original nested fucntion into smaller, single-purpose functions with top-level summaries, making it much clearer and easier to maintain:
- `normalizeName`: Cleans up and capitalises a user's name.
- `sortUsersByName`: Sorts users by name in a case-insensitive way.
- `formatUsers`: Applies name normalisation to each user.
- `displayUsers`: Logs the final list of users.
- `processUsers`: Main function that orchestrates the sorting, formatting, and displaying of users
This modular approach allows for easier testing, debugging, and future enhancements. Each function has a clear responsibility, making the codebase cleaner and more maintainable. Obviously, if the functions are easy to read and understand, there is no need to write comments for them.

### Reflections:
#### Why is breaking down functions beneficial?
I think it could be beneficial because if we write the functions in a modular way, it makes the code not just easier to read, but also easier to test and maintain. Each function has a single responsibility, so it‚Äôs clear what it does without needing to understand the entire codebase. This reduces complexity and makes it easier to spot bugs or add new features later.
#### How did refactoring improve the structure of the code?
In the example, refactoring helped create a clear flow of logic. E.g. processUsers orchestrates the entire process, while each smaller function handles a specific task. This makes it easier to follow the code‚Äôs purpose and understand how each part contributes to the overall functionality (*"sort, format, display"*). 

## Clean Code Testing
### How do unit tests help keep code clean?

Writing unit tests for `formatUser` function `from test/userUtils.ts` helped clarify the function‚Äôs intended behaviour and made the code easier to reason about. Based on my own experience writing and running these tests, here‚Äôs how they improved the code:

---

‚úÖ **1. Clarified function behaviour**  
By explicitly testing:
- `formatUser(testUser)` ‚ûù `Jane Doe <jane.doe@example.com>`  
- `formatUser(testUser, true)` ‚ûù `Jane Doe <ja***@example.com>`  

‚Ä¶it became clear what the function is expected to do. This removes ambiguity for future developers (or my future self) and avoids needing to read the implementation to understand its purpose.

---

‚úÖ **2. Encouraged simpler, modular code**  
To pass the tests, the function had to:
- stay focused on a single task (formatting + optional masking),
- avoid unrelated logic or side effects,
- stay short and easy to read.  

This aligns well with clean code principles like **single responsibility** and **readability**.

---

‚úÖ **3. Made the function safer and more predictable**  
Even though I didn‚Äôt write all edge case tests yet, writing the initial tests made me think about inputs like:
- short or malformed emails,
- missing names or null values.

This mindset reduces bugs and improves long-term maintainability.

---

‚úÖ **4. Gave confidence to refactor**  
With tests in place, I now have a safety net. If I or someone else changes the function later, the tests will catch regressions. This gives me confidence to refactor while keeping the code clean and functional.

---

If I had more time, I‚Äôd also consider adding tests for edge cases like:
- empty `firstName` or `lastName`
- malformed or missing email
- `undefined` or `null` user input

These would help push the function toward being even cleaner and more defensive.

### What issues did you find while testing?

- The function didn‚Äôt handle edge cases like missing names, short or malformed emails, or `undefined` input.
- It assumed valid input without checks, which could cause errors in real-world use (e.g., API data).
- Writing tests revealed the need for validation and defensive coding.
- The process showed how even basic testing improves reliability and highlights weak spots.

When implementing the Jest tests, I got an error saying describe was not defined ‚Äî I realised I needed to configure Jest properly in my TypeScript project. Once resolved, I noticed that testing forced me to better structure the code. It made me more aware of naming clarity and handling optional parameters like maskEmail. Overall, the process helped me think more critically about clean design and function responsibility.

I ran the tests using the command:
```bash
npx jest
```
and they passed successfully, as shown in the screenshot below:
![Test for running jest](<Screenshot 2025-06-19 at 3.08.50‚ÄØpm.png>)


## Error Handling & Guard Clauses

- **Error handling**: preventing your app from crashing or behaving unpredictably when things go wrong.
- **Guard clauses** early return conditions to handle invalid input or stop execution early.

So from the previous issue, I created userUtils.ts with a `formatUser` function that formats user data. Now, I‚Äôll add error handling and guard clauses to make it more robust.


### What was the issue with the original code?

In the earlier version of my `formatUser` function, there were no checks for invalid or incomplete input. If the function received `undefined`, `null`, or an object without a `firstName` or `lastName`, it would still attempt to run and return unpredictable or broken output ‚Äî or even throw an error. This made the function fragile and harder to maintain.

---

### How does handling errors improve reliability?

I added basic **error handling** using **guard clauses** ‚Äî early return conditions that stop the function from continuing if the input isn‚Äôt valid. For example:

```ts
if (!user || typeof user !== 'object') return 'Invalid user';
if (!user.firstName || !user.lastName) return 'Missing name';
```
So that it checks for invalid input like not having a user object or missing names. This prevents errors later on.  This not only made the function safer but also improved readability by reducing unnecessary nesting.


## Commenting & Documentation

I asked myself, "How can I make my code easier to understand for others (and myself in the future)?"
What are some of the best practices for writing comments and documentation? Besides the practices that I have already done in previous issues and experiences, I found these tips helpful:

### ‚úÖ What I‚Äôve Already Done During This Internship

- **Descriptive file-level comments**  
  ‚Üí I added a short summary at the top of `userUtils.ts` explaining the purpose of the file.
  ```ts
  /** 
   * userUtils.ts
   * This module provides utility functions for formatting user information. 
   * It includes an options parameter for email masking.
   **/
    ```
- **Clear function documentation using JSDoc**
    ‚Üí I documented formatUser with parameter descriptions, return value, and usage behaviour:
    ```ts
    /**
    * Formats a user's full name and email.
    * If maskEmail is true, the email will be partially masked for privacy.
    * Falls back to an empty string if email is missing or undefined.
    *
    * @param user - The user object containing firstName, lastName, and optional email.
    * @param maskEmail - Whether to mask the email address.
    * @returns A formatted string like "John Doe <jo***@domain.com>"
    */
    ```
    This kind of documentation improves clarity and helps other developers understand how to use the function correctly without digging into the implementation.

### ‚ùå What I Could Improve
**When to Use Comments**
- To explain why something is done (not just what is done).
- When working with complex logic that may not be self-explanatory.

And I think it is also important to **improve the code itself (clean codes)** instead of writing a comment to explain it. If the code is clear and self-explanatory, comments may not be necessary. For example:
- Clear naming (like formatUser) reduces the need for comments.
- Short, focused functions often explain themselves.
- Comments should not repeat what the code already clearly says.


### üí¨ When should you add comments?

I found comments most helpful when they explain **why** something is done, especially if the reason isn‚Äôt obvious just by looking at the code. I used file-level comments to give context at the top of the `userUtils.ts` file and JSDoc comments to describe what the `formatUser` function does and how to use it.

So for me, I add comments when:
- I want to give a quick summary of what the file or function is about.
- The logic might not be super obvious at first glance.
- I‚Äôm writing utility code that someone else might use or maintain later.


### ü§´ When should you avoid comments and instead improve the code?

As I mentioned, I realised that sometimes the best way to make code clear is to **write it more clearly** ‚Äî not explain it after the fact. For example, instead of writing a comment like `// this function formats the user`, I made sure the function is just called `formatUser`.

I try to avoid comments when:
- The code can be made clearer with better names.
- The comment is just repeating what the code says.
- A small refactor (like splitting logic into smaller functions) would make things self-explanatory.

This way, the code stays cleaner and easier to maintain without relying too much on comments that might get outdated later.





