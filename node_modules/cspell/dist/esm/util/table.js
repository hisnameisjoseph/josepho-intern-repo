import chalk from 'chalk';
import { ansiWidth, pad, pruneTextEnd } from './pad.js';
export function tableToLines(table, deliminator) {
    const del = deliminator || table.deliminator || ' | ';
    const columnWidths = [];
    const maxColumnWidthsMap = table.maxColumnWidths || {};
    const { header, rows } = table;
    const simpleHeader = header.map((col) => (Array.isArray(col) ? col[1] : col));
    const columnFieldNames = header.map((col) => (Array.isArray(col) ? col[0] : col));
    const maxColumnWidths = columnFieldNames.map((field, idx) => maxColumnWidthsMap[field] ?? maxColumnWidthsMap[idx]);
    function getCell(row, col) {
        return getCellFromRow(rows[row], col);
    }
    function getCellFromRow(row, col) {
        if (!row)
            return undefined;
        if (Array.isArray(row)) {
            return row[col];
        }
        const fieldName = columnFieldNames[col];
        return row[fieldName];
    }
    function rowToCells(row) {
        if (Array.isArray(row)) {
            return row;
        }
        return columnFieldNames.map((fieldName) => row[fieldName]);
    }
    function getText(col, maxWidth) {
        return !col ? '' : typeof col === 'string' ? pruneTextEnd(col, maxWidth) : col(maxWidth);
    }
    function getRCText(row, col, maxWidth) {
        return getText(getCell(row, col), maxWidth);
    }
    function recordHeaderWidths(header) {
        header.forEach((col, idx) => {
            columnWidths[idx] = Math.max(ansiWidth(col), columnWidths[idx] || 0);
        });
    }
    function recordColWidths() {
        for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {
            for (let colIndex = 0; colIndex < columnFieldNames.length; colIndex++) {
                columnWidths[colIndex] = Math.max(ansiWidth(getRCText(rowIndex, colIndex, undefined)), columnWidths[colIndex] || 0);
            }
        }
    }
    function justifyRow(c, i) {
        return pad(c, columnWidths[i]);
    }
    function toHeaderLine(header) {
        return decorateRowWith(header.map((c, i) => getText(c, columnWidths[i])), justifyRow, headerDecorator).join(del);
    }
    function toLine(row) {
        return decorateRowWith(rowToCells(row).map((c, i) => getText(c, columnWidths[i])), justifyRow).join(del);
    }
    function* process() {
        yield toHeaderLine(simpleHeader);
        yield* rows.map(toLine);
    }
    function sumColumnWidths() {
        return columnWidths.reduce((sum, width) => sum + width, 0);
    }
    function adjustColWidths() {
        for (let i = 0; i < columnWidths.length; i++) {
            const mw = maxColumnWidths[i];
            if (!mw)
                continue;
            columnWidths[i] = Math.min(columnWidths[i], mw);
        }
        if (!table.terminalWidth)
            return;
        const dWidth = (columnWidths.length - 1) * ansiWidth(del);
        const lineWidth = table.terminalWidth - dWidth;
        if (lineWidth <= columnWidths.length * 2) {
            const fixedWidth = Math.max(Math.min(...columnWidths), 5);
            for (let i = 0; i < columnWidths.length; i++) {
                columnWidths[i] = fixedWidth;
            }
            return;
        }
        if (columnWidths.length === 1) {
            columnWidths[0] = lineWidth;
            return;
        }
        function trimWidestColumn(neededToTrim) {
            let first = 0;
            let second = 0;
            for (let i = 0; i < columnWidths.length; i++) {
                if (columnWidths[i] > columnWidths[first]) {
                    second = first;
                    first = i;
                }
                else if (columnWidths[i] > columnWidths[second]) {
                    second = i;
                }
            }
            const diff = Math.max(columnWidths[first] - columnWidths[second], 1);
            columnWidths[first] -= Math.min(diff, neededToTrim);
        }
        for (let sum = sumColumnWidths(); sum > lineWidth; sum = sumColumnWidths()) {
            trimWidestColumn(sum - lineWidth);
        }
    }
    recordHeaderWidths(simpleHeader);
    recordColWidths();
    adjustColWidths();
    return [...process()];
}
function headerDecorator(t) {
    return chalk.bold(chalk.underline(t));
}
export function decorateRowWith(row, ...decorators) {
    return decorators.reduce((row, decorator) => row.map(decorator), row);
}
//# sourceMappingURL=table.js.map