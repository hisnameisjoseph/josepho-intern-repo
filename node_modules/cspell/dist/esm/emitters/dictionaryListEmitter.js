import * as iPath from 'node:path';
import chalk from 'chalk';
import { console } from '../console.js';
import { pruneTextEnd, pruneTextStart } from '../util/pad.js';
import { tableToLines } from '../util/table.js';
import { formatDictionaryLocation } from './helpers.js';
const maxWidth = 120;
export function emitListDictionariesResults(results, options) {
    const report = calcListDictsResultsReport(results, options);
    console.log(report.table);
    if (report.errors) {
        console.error('Errors:');
        console.error(report.errors);
    }
}
export function calcListDictsResultsReport(results, options) {
    if (options.color === true) {
        chalk.level = 2;
    }
    else if (options.color === false) {
        chalk.level = 0;
    }
    const col = new Intl.Collator();
    results.sort((a, b) => col.compare(a.name, b.name));
    const header = calcHeaders(options);
    const rows = results.map((r) => dictTableRowToTableRow(emitDictResult(r, options)));
    const t = tableToLines({
        header,
        rows,
        terminalWidth: options.lineWidth || process.stdout.columns || maxWidth,
        deliminator: ' ',
        maxColumnWidths: {
            locales: 12,
            fileTypes: 40,
        },
    });
    return {
        table: t.map((line) => line.trimEnd()).join('\n'),
        errors: '',
    };
}
function calcHeaders(options) {
    const showLocation = options.dictionaryPathFormat !== 'hide' && (options.options.showLocation ?? true);
    const showLocales = options.options.showLocales ?? true;
    const showFileTypes = options.options.showFileTypes ?? true;
    const headers = [['name', 'Dictionary']];
    showLocales && headers.push(['locales', 'Locales']);
    showFileTypes && headers.push(['fileTypes', 'File Types']);
    showLocation && headers.push(['location', 'Dictionary Location']);
    return headers;
}
function emitDictResult(r, options) {
    const a = r.enabled ? '*' : ' ';
    const dictColor = r.enabled ? chalk.yellowBright : chalk.rgb(200, 128, 50);
    const n = (width) => dictColor(pruneTextEnd(r.name, width && width - a.length) + a);
    const c = colorize(chalk.white);
    const locales = (width) => c(pruneTextEnd(r.locales?.join(',') || '', width));
    const fileTypes = (width) => c(pruneTextEnd(r.fileTypes?.join(',') || '', width));
    if (!r.path) {
        return {
            name: n,
            location: c(r.inline?.join(', ') || ''),
            locales,
            fileTypes,
        };
    }
    return {
        name: n,
        location: (widthSrc) => c((r.path &&
            pruneTextStart(formatDictionaryLocation(r.path, widthSrc ?? maxWidth, { iPath, ...options }), widthSrc ?? maxWidth)) ||
            ''),
        locales,
        fileTypes,
    };
}
function dictTableRowToTableRow(row) {
    return Object.fromEntries(Object.entries(row));
}
function colorize(fn) {
    return (s) => (s ? fn(s) : '');
}
//# sourceMappingURL=dictionaryListEmitter.js.map